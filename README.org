#+TITLE: boost-python-stdcon: Boost.Python Extension for Containers Automatic Conversion
#+AUTHOR: Yujie Wen
#+Email: yjwen.ty@qq.com
#+OPTIONS: toc:nil

* Introduction
  Often we use Python to collect some data and pass them to C++
  functions for further process. Data is organized in Python builtin
  data structures (list, dict and etc), while C++ functions accept
  some standard containers or data structure as arguments. To bridge
  such data path from Python to C++ by using ~boost::python~, we
  should either expose the C++ standard containers or data structures
  as Python extension classes or create wrapper functions that accept
  Python objects as arguments and in those wapper functions prepare
  the ~std~ containers with data extracted from the Python
  objects. Either way will involve boilplate and tedious coding jobs
  as the C++ interface grows.

  ~boost-python-stdcon~ is a header-only library that automates the
  conversion between C++ standard containers/data structures and their
  Python counterparts. It embeds the automatic conversion code into
  ~boost::python~ namespace to enable it to recognize function
  arguments and results of ~std~ container types and to do the
  conversion in ~boost::python~'s own wrapper functions.

  Here is a simple example. Let's expose the below simple C++ function
  to Python so that it can accept data in a Python list.
  #+begin_src c++
    int sum(std::vector<int> const &vec);
  #+end_src

  With the stock ~boost::python~ library, we should create a wrapper
  function that accepts one Python list object and prepare the
  ~vector~ argument in that wrapper function manually.
  #+begin_src c++
    #include <boost/python/extract.hpp>

    int pySum(PyObject* obj)
    {
      std::vector<int> vec;
      // Assuming obj is a list. Exact int values from obj and prepapre
      // vec.
      vec.reserve(PyList_Size(obj));
      for (Py_ssize_t i = 0; i < PyList_Size(obj); ++i) {
        vec.push_back(boost::python::extract<int>(PyList_GetItem(obj, i)));
      }
      return sum(vec); // Call sum
    }
  #+end_src

  And finally, register the wrapper function to Python.
  #+begin_src c++
    #include <boost/python.hpp>

    BOOST_PYTHON_MODULE(foo) {
      boost::python::def("sum", &pySum);
    }
  #+end_src

  But with ~boost-python-stdcon~, the wrapper function is no longer
  required and ~sum~ can be registered to Python directly. All is done
  by including a provided header file /vector_arg.hpp/.
  #+begin_src c++
    #include <vector_arg.hpp> // Provided by boost-python-stdcon

    BOOST_PYTHON_MODULE(foo) {
      boost::python::def("sum", &sum);
    }
  #+end_src

* Usage

  This library is header-only. Download the code package and unpack
  it to somewhere in your local directory. Add the /include/ directory
  to your C++ compiler's include file search path. Then add the proper
  header file to enable ~boost::python~ for specific container
  types.

* Argument Conversion

  For converting python containers to C++ containers as function
  arguments, please include the proper header file listed in the table
  below.

  | C++ Container   | Python Container     | Header file for         |
  |                 |                      | argument conversion     |
  |-----------------+----------------------+-------------------------|
  | ~vector~        | ~list~               | ~vector_arg.hpp~        |
  | ~list~          | ~list~               | ~list_arg.hpp~          |
  | ~forward_list~  | ~list~               | ~forward_list_arg.hpp~  |
  | ~map~           | ~dict~               | ~map_arg.hpp~           |
  | ~unordered_map~ | ~dict~               | ~unordered_map_arg.hpp~ |
  | ~set~           | ~set~ or ~frozenset~ | ~set_arg.hpp~           |
  | ~unordered_set~ | ~set~ or ~frozenset~ | ~unordered_set_arg.hpp~ |
  | ~pair~          | ~tuple~ of size 2    | ~pair_arg.hpp~          |
  | ~tuple~         | ~tuple~              | ~tuple_arg.hpp~         |

** Restriction on Copy-Only Semantic

   The argument conversion is done by creating temporary C++ container
   object and COPYING each element of Python container to that
   temporary C++ object. That means any change to the container itself
   in C++ side is discarded and cannot affect the original Python
   container. To reflect the Copy-Only Semantic, the conversion is
   restricted to container value type, constant reference type and
   rvalue reference type. The following code shows some example of
   acceptable arguments.

   #+begin_src c++
     void foo_0(std::vector<int> v); // A vector value, convertible
     void foo_1(std::vector<int> const &v); // Constant reference to a
                                            // vector, convertible
     void foo_2(std::vector<int> &&v); // Rvalue reference to a vector,
                                       // convertible

     void foo_3(std::vector<int> &v); // Reference to a vector, NOT
                                      // convertible
   #+end_src
